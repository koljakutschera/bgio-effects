/// <reference types="react" />
import type { F, O, U } from 'ts-toolbelt';
import type { Timeline } from './timeline';
/**
 * Type of effect.create function.
 */
declare type CreateFn = (arg: any) => any;
/**
 * Object shape defining a single effect.
 */
interface EffectConfig {
    create?: CreateFn;
    duration?: number;
}
interface EffectWithCreate extends EffectConfig {
    create: CreateFn;
}
interface EffectWithoutCreate extends EffectConfig {
    create?: undefined;
}
/**
 * Map of effect name strings to EffectConfig interfaces.
 */
declare type EffectsMap = Record<string, EffectConfig>;
/**
 * Plugin configuration object shape.
 */
export interface EffectsPluginConfig {
    effects: EffectsMap;
}
/**
 * Effect types generated by the plugin itself.
 */
declare type BuiltinEffect = 'effects:start' | 'effects:end';
/**
 * Type describing the possible effect objects produced by an EffectsPlugin.
 * @param E - A map of EffectConfig interfaces to derive the shapes from.
 */
export declare type Effect<E extends EffectsMap> = U.IntersectOf<O.UnionOf<{
    [K in keyof E]: E[K] extends EffectWithCreate ? {
        type: K;
        payload: F.Return<O.At<E[K], 'create'>>;
    } : E[K] extends EffectWithoutCreate ? {
        type: K;
    } : never;
}>> | {
    type: BuiltinEffect;
};
/**
 * Type describing the queue of effects persisted to game state.
 * @param E - A map of EffectConfig interfaces to derive the data from.
 */
export declare type Queue<E extends EffectsMap> = Array<Effect<E> & {
    t: number;
}>;
/**
 * Type describing the EffectsPlugin data object.
 * @param E - A map of EffectConfig interfaces to derive the data from.
 */
export declare type Data<E extends EffectsMap> = {
    id: string;
    duration: number;
    queue: Queue<E>;
};
declare type Duration = number;
declare type Position = number | string;
export declare type TimingParams = [Position, Duration];
/**
 * Generic type for the EffectsPlugin API.
 * @param E - A tuple of EffectConfig interfaces to derive the API from.
 */
export declare type API<E extends EffectsMap> = {
    timeline: Timeline<E>;
} & U.IntersectOf<O.UnionOf<{
    [K in keyof E]: E[K] extends EffectWithCreate ? O.Record<K, (arg: F.Parameters<O.At<E[K], 'create'>>[0], position?: TimingParams[0], duration?: TimingParams[1]) => void> : E[K] extends EffectWithoutCreate ? O.Record<K, (position?: TimingParams[0], duration?: TimingParams[1]) => void> : never;
}>>;
/**
 * Effects plugin API mixin to intersect with boardgame.io `Ctx` type.
 * @example
 * import { Game, Ctx } from 'boardgame.io';
 * import { EffectsCtxMixin } from 'bgio-effects';
 *
 * const EffectsConfig = {
 *   effects: {
 *     explode: {}
 *   }
 * } as const;
 *
 * const game: Game<any, Ctx & EffectsCtxMixin<typeof EffectsConfig>> = {
 *   moves: {
 *     A: (G, ctx) => ctx.effects.explode(), // fully typed
 *   }
 * };
 */
export declare type EffectsCtxMixin<C extends EffectsPluginConfig> = {
    effects: API<C['effects']>;
};
declare type CbReturn = void | (() => void);
export declare type ListenerArgs<E extends EffectsMap> = [
    '*',
    (...cbArgs: O.UnionOf<{
        [K in keyof E]: E[K] extends EffectWithCreate ? [K, F.Return<O.At<E[K], 'create'>>] : [K, undefined];
    }>) => CbReturn,
    React.DependencyList
] | O.UnionOf<{
    [K in keyof E]: [
        K,
        E[K] extends EffectWithCreate ? (payload: F.Return<O.At<E[K], 'create'>>) => CbReturn : () => CbReturn,
        React.DependencyList
    ];
}> | [BuiltinEffect, () => CbReturn, React.DependencyList];
export {};
